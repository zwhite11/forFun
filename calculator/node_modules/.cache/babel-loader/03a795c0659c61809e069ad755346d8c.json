{"ast":null,"code":"import { factory } from './utils/factory';\nimport { version } from './version';\nimport { createBigNumberE, createBigNumberPhi, createBigNumberPi, createBigNumberTau } from './utils/bignumber/constants';\nimport { pi, tau, e, phi } from './plain/number';\nexport const createTrue =\n/* #__PURE__ */\nfactory('true', [], () => true);\nexport const createFalse =\n/* #__PURE__ */\nfactory('false', [], () => false);\nexport const createNull =\n/* #__PURE__ */\nfactory('null', [], () => null);\nexport const createInfinity =\n/* #__PURE__ */\nrecreateFactory('Infinity', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(Infinity) : Infinity);\nexport const createNaN =\n/* #__PURE__ */\nrecreateFactory('NaN', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(NaN) : NaN);\nexport const createPi =\n/* #__PURE__ */\nrecreateFactory('pi', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? createBigNumberPi(BigNumber) : pi);\nexport const createTau =\n/* #__PURE__ */\nrecreateFactory('tau', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? createBigNumberTau(BigNumber) : tau);\nexport const createE =\n/* #__PURE__ */\nrecreateFactory('e', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? createBigNumberE(BigNumber) : e); // golden ratio, (1+sqrt(5))/2\n\nexport const createPhi =\n/* #__PURE__ */\nrecreateFactory('phi', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? createBigNumberPhi(BigNumber) : phi);\nexport const createLN2 =\n/* #__PURE__ */\nrecreateFactory('LN2', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(2).ln() : Math.LN2);\nexport const createLN10 =\n/* #__PURE__ */\nrecreateFactory('LN10', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(10).ln() : Math.LN10);\nexport const createLOG2E =\n/* #__PURE__ */\nrecreateFactory('LOG2E', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E);\nexport const createLOG10E =\n/* #__PURE__ */\nrecreateFactory('LOG10E', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E);\nexport const createSQRT1_2 =\n/* #__PURE__ */\nrecreateFactory( // eslint-disable-line camelcase\n'SQRT1_2', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber('0.5').sqrt() : Math.SQRT1_2);\nexport const createSQRT2 =\n/* #__PURE__ */\nrecreateFactory('SQRT2', ['config', '?BigNumber'], ({\n  config,\n  BigNumber\n}) => config.number === 'BigNumber' ? new BigNumber(2).sqrt() : Math.SQRT2);\nexport const createI =\n/* #__PURE__ */\nrecreateFactory('i', ['Complex'], ({\n  Complex\n}) => Complex.I); // for backward compatibility with v5\n\nexport const createUppercasePi =\n/* #__PURE__ */\nfactory('PI', ['pi'], ({\n  pi\n}) => pi);\nexport const createUppercaseE =\n/* #__PURE__ */\nfactory('E', ['e'], ({\n  e\n}) => e);\nexport const createVersion =\n/* #__PURE__ */\nfactory('version', [], () => version); // helper function to create a factory with a flag recreateOnConfigChange\n// idea: allow passing optional properties to be attached to the factory function as 4th argument?\n\nfunction recreateFactory(name, dependencies, create) {\n  return factory(name, dependencies, create, {\n    recreateOnConfigChange: true\n  });\n}","map":null,"metadata":{},"sourceType":"module"}