{"ast":null,"code":"import { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory';\nimport { hasOwnProperty, isLegacyFactory, lazy, traverse } from '../../utils/object';\nimport { contains } from '../../utils/array';\nimport { ArgumentsError } from '../../error/ArgumentsError';\nimport { warnOnce } from '../../utils/log';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    const num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (isLegacyFactory(value)) {\n        // legacy factories don't always have a name,\n        // let's not handle them via the new flatValues\n        _importLegacyFactory(value, options);\n      } else if (Array.isArray(value)) {\n        value.forEach(item => flattenImports(flatValues, item));\n      } else if (typeof value === 'object') {\n        for (const name in value) {\n          if (value.hasOwnProperty(name)) {\n            flattenImports(flatValues, value[name], name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        const flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    const flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (const name in flatValues) {\n      if (flatValues.hasOwnProperty(name)) {\n        // console.log('import', name)\n        const value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, {\n        [value.signature]: value\n      });\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    const wrapper = function wrapper() {\n      const args = [];\n\n      for (let i = 0, len = arguments.length; i < len; i++) {\n        const arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  // TODO: _importLegacyFactory is deprecated since v6.0.0, clean up some day\n\n\n  function _importLegacyFactory(factory, options) {\n    warnOnce('Factories of type { name, factory } are deprecated since v6. ' + 'Please create your factory functions using the math.factory function.');\n\n    if (typeof factory.name === 'string') {\n      const name = factory.name;\n      const existingTransform = name in math.expression.transform;\n      const namespace = factory.path ? traverse(math, factory.path) : math;\n      const existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;\n\n      const resolver = function () {\n        let instance = load(factory);\n\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {// replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (options.silent) {\n          return existing;\n        } else {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      const key = factory.path ? factory.path + '.' + factory.name : factory.name;\n      importedFactories[key] = factory;\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options, name = factory.fn) {\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    const namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    const existingTransform = name in math.expression.transform;\n    const existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;\n\n    const resolver = function () {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      const dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(dependency => {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      let instance =\n      /* #__PURE__ */\n      factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, () => namespace[name]);\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, () => namespace[name]);\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && typeof fn.signatures === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !unsafe.hasOwnProperty(name);\n  }\n\n  function legacyFactoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !unsafe.hasOwnProperty(factory.name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !unsafe.hasOwnProperty(factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  const unsafe = {\n    'expression': true,\n    'type': true,\n    'docs': true,\n    'error': true,\n    'json': true,\n    'chain': true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}","map":null,"metadata":{},"sourceType":"module"}