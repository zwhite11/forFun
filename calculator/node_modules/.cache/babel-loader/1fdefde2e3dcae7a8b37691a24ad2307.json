{"ast":null,"code":"import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nconst name = 'simplifyCore';\nconst dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport const createSimplifyCore =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  equal,\n  isZero,\n  add,\n  subtract,\n  multiply,\n  divide,\n  pow,\n  ConstantNode,\n  OperatorNode,\n  FunctionNode,\n  ParenthesisNode\n}) => {\n  const node0 = new ConstantNode(0);\n  const node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      const a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      const a0 = simplifyCore(node.args[0]);\n      const a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(a0)) {\n          if (isZero(a0.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(a0.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return a0;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [a0, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [a0, a1] : [a0]);\n      } else if (node.op === '-') {\n        if (isConstantNode(a0) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(a0.value, a1.value));\n          } else if (isZero(a0.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return a0;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [a0, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [a0, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(a0)) {\n          if (isZero(a0.value)) {\n            return node0;\n          } else if (equal(a0.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(a0.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return a0;\n          } else if (isOperatorNode(a0) && a0.isBinary() && a0.op === node.op) {\n            const a00 = a0.args[0];\n\n            if (isConstantNode(a00)) {\n              const a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, a0.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, a0], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(a0)) {\n          if (isZero(a0.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(a0.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return a0;\n          } else {\n            if (isConstantNode(a0)) {\n              // fold constant\n              return new ConstantNode(pow(a0.value, a1.value));\n            } else if (isOperatorNode(a0) && a0.isBinary() && a0.op === '^') {\n              const a01 = a0.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [a0.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      const c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      const args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":null,"metadata":{},"sourceType":"module"}