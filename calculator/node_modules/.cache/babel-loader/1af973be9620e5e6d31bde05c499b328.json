{"ast":null,"code":"import { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nconst name = 'usolve';\nconst dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport const createUsolve =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  matrix,\n  divideScalar,\n  multiplyScalar,\n  subtract,\n  equalScalar,\n  DenseMatrix\n}) => {\n  const solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n  /**\n   * Solves the linear equation system by backward substitution. Matrix must be an upper triangular matrix.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [[8], [9]]\n   *\n   * See also:\n   *\n   *    lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function (m, b) {\n      // process matrix\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function (m, b) {\n      // process matrix\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function (a, b) {\n      // create dense matrix from array\n      const m = matrix(a); // use matrix implementation\n\n      const r = _denseBackwardSubstitution(m, b); // result\n\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    const bdata = b._data; // rows & columns\n\n    const rows = m._size[0];\n    const columns = m._size[1]; // result\n\n    const x = []; // arrays\n\n    const data = m._data; // backward solve m * x = b, loop columns (backwards)\n\n    for (let j = columns - 1; j >= 0; j--) {\n      // b[j]\n      const bj = bdata[j][0] || 0; // x[j]\n\n      let xj; // backward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        const vjj = data[j][j]; // check vjj\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (let i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];\n        }\n      } else {\n        // zero value @ j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    } // return column vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    const bdata = b._data; // rows & columns\n\n    const rows = m._size[0];\n    const columns = m._size[1]; // matrix arrays\n\n    const values = m._values;\n    const index = m._index;\n    const ptr = m._ptr; // vars\n\n    let i, k; // result\n\n    const x = []; // backward solve m * x = b, loop columns (backwards)\n\n    for (let j = columns - 1; j >= 0; j--) {\n      // b[j]\n      const bj = bdata[j][0] || 0; // backward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        let vjj = 0; // upper triangular matrix values & index (column j)\n\n        const jvalues = [];\n        const jindex = []; // first & last indeces in column\n\n        const f = ptr[j];\n        let l = ptr[j + 1]; // values in column, find value @ [j, j], loop backwards\n\n        for (k = l - 1; k >= f; k--) {\n          // row\n          i = index[k]; // check row\n\n          if (i === j) {\n            // update vjj\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jvalues.push(values[k]);\n            jindex.push(i);\n          }\n        } // at this point we must have a value @ [j, j]\n\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved, there is no value @ [j, j]\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        const xj = divideScalar(bj, vjj); // loop upper triangular\n\n        for (k = 0, l = jindex.length; k < l; k++) {\n          // row\n          i = jindex[k]; // update copy of b\n\n          bdata[i] = [subtract(bdata[i][0], multiplyScalar(xj, jvalues[k]))];\n        } // update x\n\n\n        x[j] = [xj];\n      } else {\n        // update x\n        x[j] = [0];\n      }\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"module"}