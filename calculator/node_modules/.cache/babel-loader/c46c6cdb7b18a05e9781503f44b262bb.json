{"ast":null,"code":"import { factory } from '../../utils/factory';\nconst name = 'composition';\nconst dependencies = ['typed', 'addScalar', 'combinations', 'isNegative', 'isPositive', 'isInteger', 'larger'];\nexport const createComposition =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  addScalar,\n  combinations,\n  isPositive,\n  isNegative,\n  isInteger,\n  larger\n}) => {\n  /**\n   * The composition counts of n into k parts.\n   *\n   * composition only takes integer arguments.\n   * The following condition must be enforced: k <= n.\n   *\n   * Syntax:\n   *\n   *   math.composition(n, k)\n   *\n   * Examples:\n   *\n   *    math.composition(5, 3) // returns 6\n   *\n   * See also:\n   *\n   *    combinations\n   *\n   * @param {Number | BigNumber} n    Total number of objects in the set\n   * @param {Number | BigNumber} k    Number of objects in the subset\n   * @return {Number | BigNumber}     Returns the composition counts of n into k parts.\n   */\n  return typed(name, {\n    'number | BigNumber, number | BigNumber': function (n, k) {\n      if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {\n        throw new TypeError('Positive integer value expected in function composition');\n      } else if (larger(k, n)) {\n        throw new TypeError('k must be less than or equal to n in function composition');\n      }\n\n      return combinations(addScalar(n, -1), addScalar(k, -1));\n    }\n  });\n});","map":null,"metadata":{},"sourceType":"module"}