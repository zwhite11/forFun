{"ast":null,"code":"/**\n * THIS FILE IS AUTO-GENERATED\n * DON'T MAKE CHANGES HERE\n */\nimport { config } from './configReadonly';\nimport { createNode, createArrayNode, createBlockNode, createConstantNode, createObjectNode, createParenthesisNode, createRelationalNode, createChainClass, createReviver, createConditionalNode, createOperatorNode, createRangeNode, createFunctionAssignmentNode, createChain, createAccessorNode, createAssignmentNode, createIndexNode, createSymbolNode, createFunctionNode, createParse, createEvaluate, createParserClass, createHelpClass, createSimplify, createRationalize, createHelp, createCompile, createParser, createDerivative, createApplyTransform, createFilterTransform, createMapTransform, createForEachTransform, createMaxTransform, createMinTransform, createSubsetTransform, createConcatTransform, createRangeTransform, createSumTransform, createIndexTransform, createColumnTransform, createRowTransform, createStdTransform, createMeanTransform, createVarianceTransform } from '../factoriesAny';\nimport { ResultSet, Complex, Range, eye, _false, _null, _true, BigNumber, Matrix, e, i, LN10, LOG10E, _NaN, pi, SQRT1_2, // eslint-disable-line camelcase\ntau, efimovFactor, fineStructure, sackurTetrode, weakMixingAngle, Fraction, LN2, phi, SQRT2, DenseMatrix, _Infinity, typed, isInteger, isNumeric, isPositive, isNaN, equalScalar, number, boolean, complex, splitUnit, unaryPlus, apply, cube, expm1, log10, multiplyScalar, sign, square, bitNot, arg, im, not, filter, forEach, map, erf, format, isPrime, acos, acot, acsc, asec, asin, atan, atanh, cosh, coth, csch, sech, sinh, tanh, combinations, pickRandom, randomInt, LOG2E, clone, hasNumericValue, typeOf, string, fraction, unaryMinus, addScalar, exp, log2, sqrt, conj, getMatrixDataType, mode, print, acosh, acsch, asinh, cos, csc, sin, random, version, isNegative, SparseMatrix, matrix, cbrt, gcd, mod, nthRoot, xgcd, bitAnd, bitXor, or, concat, diag, identity, ones, reshape, size, subset, zeros, to, round, leftShift, rightLogShift, compare, compareText, smaller, larger, unequal, max, ImmutableDenseMatrix, FibonacciHeap, sparse, acoth, atan2, sec, add, trace, composition, isZero, abs, floor, multiply, dotMultiply, re, flatten, resize, squeeze, prod, pow, dotPow, rightArithShift, compareNatural, equalText, largerEq, partitionSelect, min, Spa, asech, tan, setSize, norm, quantileSeq, gamma, bignumber, lcm, bitOr, kron, transpose, numeric, and, smallerEq, sort, cot, dot, sum, factorial, permutations, ceil, subtract, cross, ctranspose, equal, Index, setCartesian, setDistinct, setIsSubset, setPowerset, index, fix, range, divideScalar, nthRoots, lsolve, deepEqual, setDifference, setMultiplicity, hypot, lup, slu, det, distance, stirlingS2, catalan, xor, row, dotDivide, Unit, createUnit, setSymDifference, qr, inv, sqrtm, intersect, bellNumbers, atomicMass, bohrMagneton, boltzmann, conductanceQuantum, deuteronMass, electronMass, faraday, firstRadiation, gravitationConstant, hartreeEnergy, klitzing, magneticConstant, molarMass, molarPlanckConstant, neutronMass, planckCharge, planckLength, planckTemperature, protonMass, reducedPlanckConstant, secondRadiation, stefanBoltzmann, vacuumImpedance, column, usolve, setIntersect, lusolve, expm, avogadro, classicalElectronRadius, electricConstant, fermiCoupling, gravity, loschmidt, molarMassC12, nuclearMagneton, planckMass, quantumOfCirculation, speedOfLight, wienDisplacement, log, unit, divide, median, variance, std, multinomial, bohrRadius, elementaryCharge, inverseConductanceQuantum, molarVolume, planckTime, thomsonCrossSection, log1p, mean, gasConstant, planckConstant, setUnion, kldivergence, coulomb, rydberg, mad, magneticFluxQuantum } from './pureFunctionsAny.generated';\nconst math = {}; // NOT pure!\n\nconst mathWithTransform = {}; // NOT pure!\n\nconst classes = {}; // NOT pure!\n\nexport const Node = createNode({\n  mathWithTransform\n});\nexport const ArrayNode = createArrayNode({\n  Node\n});\nexport const BlockNode = createBlockNode({\n  Node,\n  ResultSet\n});\nexport const ConstantNode = createConstantNode({\n  Node\n});\nexport const ObjectNode = createObjectNode({\n  Node\n});\nexport const ParenthesisNode = createParenthesisNode({\n  Node\n});\nexport const RelationalNode = createRelationalNode({\n  Node\n});\nexport const Chain = createChainClass({\n  math\n});\nexport const reviver = createReviver({\n  classes\n});\nexport const ConditionalNode = createConditionalNode({\n  Node\n});\nexport const OperatorNode = createOperatorNode({\n  Node\n});\nexport const RangeNode = createRangeNode({\n  Node\n});\nexport const FunctionAssignmentNode = createFunctionAssignmentNode({\n  Node,\n  typed\n});\nexport const chain = createChain({\n  Chain,\n  typed\n});\nexport const AccessorNode = createAccessorNode({\n  Node,\n  subset\n});\nexport const AssignmentNode = createAssignmentNode({\n  matrix,\n  Node,\n  subset\n});\nexport const IndexNode = createIndexNode({\n  Index,\n  Node,\n  Range,\n  size\n});\nexport const SymbolNode = createSymbolNode({\n  Unit,\n  Node,\n  math\n});\nexport const FunctionNode = createFunctionNode({\n  Node,\n  SymbolNode,\n  math\n});\nexport const parse = createParse({\n  AccessorNode,\n  ArrayNode,\n  AssignmentNode,\n  BlockNode,\n  ConditionalNode,\n  ConstantNode,\n  FunctionAssignmentNode,\n  FunctionNode,\n  IndexNode,\n  ObjectNode,\n  OperatorNode,\n  ParenthesisNode,\n  RangeNode,\n  RelationalNode,\n  SymbolNode,\n  config,\n  numeric,\n  typed\n});\nexport const evaluate = createEvaluate({\n  parse,\n  typed\n});\nexport const Parser = createParserClass({\n  parse\n});\nexport const Help = createHelpClass({\n  parse\n});\nexport const simplify = createSimplify({\n  bignumber,\n  fraction,\n  ConstantNode,\n  FunctionNode,\n  OperatorNode,\n  ParenthesisNode,\n  SymbolNode,\n  add,\n  config,\n  divide,\n  equal,\n  isZero,\n  mathWithTransform,\n  multiply,\n  parse,\n  pow,\n  subtract,\n  typed\n});\nexport const rationalize = createRationalize({\n  bignumber,\n  fraction,\n  ConstantNode,\n  FunctionNode,\n  OperatorNode,\n  ParenthesisNode,\n  SymbolNode,\n  add,\n  config,\n  divide,\n  equal,\n  isZero,\n  mathWithTransform,\n  multiply,\n  parse,\n  pow,\n  simplify,\n  subtract,\n  typed\n});\nexport const help = createHelp({\n  Help,\n  mathWithTransform,\n  typed\n});\nexport const compile = createCompile({\n  parse,\n  typed\n});\nexport const parser = createParser({\n  Parser,\n  typed\n});\nexport const derivative = createDerivative({\n  ConstantNode,\n  FunctionNode,\n  OperatorNode,\n  ParenthesisNode,\n  SymbolNode,\n  config,\n  equal,\n  isZero,\n  numeric,\n  parse,\n  simplify,\n  typed\n});\nObject.assign(math, {\n  'typeof': typeOf,\n  eye,\n  reviver,\n  false: _false,\n  null: _null,\n  true: _true,\n  e,\n  i,\n  LN10,\n  LOG10E,\n  NaN: _NaN,\n  pi,\n  SQRT1_2,\n  tau,\n  efimovFactor,\n  fineStructure,\n  sackurTetrode,\n  weakMixingAngle,\n  'E': e,\n  LN2,\n  phi,\n  SQRT2,\n  Infinity: _Infinity,\n  'PI': pi,\n  typed,\n  isInteger,\n  isNumeric,\n  isPositive,\n  isNaN,\n  equalScalar,\n  number,\n  boolean,\n  complex,\n  splitUnit,\n  unaryPlus,\n  apply,\n  cube,\n  expm1,\n  log10,\n  multiplyScalar,\n  sign,\n  square,\n  bitNot,\n  arg,\n  im,\n  not,\n  filter,\n  forEach,\n  map,\n  erf,\n  format,\n  isPrime,\n  acos,\n  acot,\n  acsc,\n  asec,\n  asin,\n  atan,\n  atanh,\n  cosh,\n  coth,\n  csch,\n  sech,\n  sinh,\n  tanh,\n  chain,\n  combinations,\n  pickRandom,\n  randomInt,\n  LOG2E,\n  clone,\n  hasNumericValue,\n  typeOf,\n  string,\n  fraction,\n  unaryMinus,\n  addScalar,\n  exp,\n  log2,\n  sqrt,\n  conj,\n  getMatrixDataType,\n  mode,\n  print,\n  acosh,\n  acsch,\n  asinh,\n  cos,\n  csc,\n  sin,\n  random,\n  version,\n  isNegative,\n  matrix,\n  cbrt,\n  gcd,\n  mod,\n  nthRoot,\n  xgcd,\n  bitAnd,\n  bitXor,\n  or,\n  concat,\n  diag,\n  identity,\n  ones,\n  reshape,\n  size,\n  subset,\n  zeros,\n  to,\n  round,\n  leftShift,\n  rightLogShift,\n  compare,\n  compareText,\n  smaller,\n  larger,\n  unequal,\n  max,\n  sparse,\n  acoth,\n  atan2,\n  sec,\n  add,\n  trace,\n  composition,\n  isZero,\n  abs,\n  floor,\n  multiply,\n  dotMultiply,\n  re,\n  flatten,\n  resize,\n  squeeze,\n  prod,\n  pow,\n  dotPow,\n  rightArithShift,\n  compareNatural,\n  equalText,\n  largerEq,\n  partitionSelect,\n  min,\n  asech,\n  tan,\n  setSize,\n  norm,\n  quantileSeq,\n  gamma,\n  bignumber,\n  lcm,\n  bitOr,\n  kron,\n  transpose,\n  numeric,\n  and,\n  smallerEq,\n  sort,\n  cot,\n  dot,\n  sum,\n  factorial,\n  permutations,\n  ceil,\n  subtract,\n  cross,\n  ctranspose,\n  equal,\n  setCartesian,\n  setDistinct,\n  setIsSubset,\n  setPowerset,\n  index,\n  fix,\n  range,\n  divideScalar,\n  nthRoots,\n  lsolve,\n  deepEqual,\n  setDifference,\n  setMultiplicity,\n  hypot,\n  lup,\n  slu,\n  det,\n  distance,\n  stirlingS2,\n  catalan,\n  xor,\n  row,\n  dotDivide,\n  createUnit,\n  setSymDifference,\n  qr,\n  inv,\n  sqrtm,\n  intersect,\n  bellNumbers,\n  atomicMass,\n  bohrMagneton,\n  boltzmann,\n  conductanceQuantum,\n  deuteronMass,\n  electronMass,\n  faraday,\n  firstRadiation,\n  gravitationConstant,\n  hartreeEnergy,\n  klitzing,\n  magneticConstant,\n  molarMass,\n  molarPlanckConstant,\n  neutronMass,\n  planckCharge,\n  planckLength,\n  planckTemperature,\n  protonMass,\n  reducedPlanckConstant,\n  secondRadiation,\n  stefanBoltzmann,\n  vacuumImpedance,\n  column,\n  usolve,\n  setIntersect,\n  lusolve,\n  expm,\n  avogadro,\n  classicalElectronRadius,\n  electricConstant,\n  fermiCoupling,\n  gravity,\n  loschmidt,\n  molarMassC12,\n  nuclearMagneton,\n  planckMass,\n  quantumOfCirculation,\n  speedOfLight,\n  wienDisplacement,\n  log,\n  unit,\n  divide,\n  median,\n  variance,\n  std,\n  multinomial,\n  bohrRadius,\n  elementaryCharge,\n  inverseConductanceQuantum,\n  molarVolume,\n  planckTime,\n  thomsonCrossSection,\n  log1p,\n  parse,\n  evaluate,\n  mean,\n  'var': variance,\n  simplify,\n  rationalize,\n  gasConstant,\n  planckConstant,\n  setUnion,\n  'eval': evaluate,\n  help,\n  kldivergence,\n  coulomb,\n  rydberg,\n  compile,\n  mad,\n  magneticFluxQuantum,\n  parser,\n  derivative,\n  config\n});\nObject.assign(mathWithTransform, math, {\n  apply: createApplyTransform({\n    isInteger,\n    typed\n  }),\n  filter: createFilterTransform({\n    typed\n  }),\n  map: createMapTransform({\n    typed\n  }),\n  forEach: createForEachTransform({\n    typed\n  }),\n  max: createMaxTransform({\n    larger,\n    typed\n  }),\n  min: createMinTransform({\n    smaller,\n    typed\n  }),\n  subset: createSubsetTransform({\n    matrix,\n    typed\n  }),\n  concat: createConcatTransform({\n    isInteger,\n    matrix,\n    typed\n  }),\n  range: createRangeTransform({\n    bignumber,\n    matrix,\n    config,\n    larger,\n    largerEq,\n    smaller,\n    smallerEq,\n    typed\n  }),\n  sum: createSumTransform({\n    bignumber,\n    fraction,\n    add,\n    config,\n    typed\n  }),\n  index: createIndexTransform({\n    Index\n  }),\n  column: createColumnTransform({\n    Index,\n    matrix,\n    range,\n    typed\n  }),\n  row: createRowTransform({\n    Index,\n    matrix,\n    range,\n    typed\n  }),\n  std: createStdTransform({\n    sqrt,\n    typed,\n    variance\n  }),\n  mean: createMeanTransform({\n    add,\n    divide,\n    typed\n  }),\n  variance: createVarianceTransform({\n    add,\n    apply,\n    divide,\n    isNaN,\n    multiply,\n    subtract,\n    typed\n  })\n});\nObject.assign(classes, {\n  ResultSet,\n  Complex,\n  Range,\n  Node,\n  ArrayNode,\n  BlockNode,\n  ConstantNode,\n  ObjectNode,\n  ParenthesisNode,\n  RelationalNode,\n  Chain,\n  BigNumber,\n  Matrix,\n  ConditionalNode,\n  OperatorNode,\n  Fraction,\n  RangeNode,\n  DenseMatrix,\n  FunctionAssignmentNode,\n  SparseMatrix,\n  ImmutableDenseMatrix,\n  FibonacciHeap,\n  AccessorNode,\n  Spa,\n  AssignmentNode,\n  Index,\n  Unit,\n  IndexNode,\n  SymbolNode,\n  FunctionNode,\n  Parser,\n  Help\n});\nChain.createProxy(math);\nexport { embeddedDocs as docs } from '../expression/embeddedDocs/embeddedDocs';","map":null,"metadata":{},"sourceType":"module"}