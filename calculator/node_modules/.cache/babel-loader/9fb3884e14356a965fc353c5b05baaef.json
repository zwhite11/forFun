{"ast":null,"code":"import { isSparseMatrix } from '../../utils/is';\nimport { format } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nconst name = 'expm';\nconst dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nexport const createExpm =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  abs,\n  add,\n  identity,\n  inv,\n  multiply\n}) => {\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    'Matrix': function (A) {\n      // Check matrix size\n      const size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n      }\n\n      const n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      const eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      const infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      const params = findParams(infNorm, eps);\n      const q = params.q;\n      const j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      const Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      let N = identity(n);\n      let D = identity(n); // Initialization (i=0)\n\n      let factor = 1; // Initialization (i=1)\n\n      let AposToI = Apos; // Cloning not necessary\n\n      let alternate = -1;\n\n      for (let i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      let R = multiply(inv(D), N); // Square j times\n\n      for (let i = 0; i < j; i++) {\n        R = multiply(R, R);\n      }\n\n      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    const n = A.size()[0];\n    let infNorm = 0;\n\n    for (let i = 0; i < n; i++) {\n      let rowSum = 0;\n\n      for (let j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    const maxSearchSize = 30;\n\n    for (let k = 0; k < maxSearchSize; k++) {\n      for (let q = 0; q <= k; q++) {\n        const j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    let qfac = 1;\n\n    for (let i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    let twoqfac = qfac;\n\n    for (let i = q + 1; i <= 2 * q; i++) {\n      twoqfac *= i;\n    }\n\n    const twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}