{"ast":null,"code":"import { deepMap } from '../../utils/collection';\nimport { factory } from '../../utils/factory';\nimport { gammaG, gammaNumber, gammaP } from '../../plain/number';\nconst name = 'gamma';\nconst dependencies = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];\nexport const createGamma =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  config,\n  multiplyScalar,\n  pow,\n  BigNumber,\n  Complex\n}) => {\n  /**\n   * Compute the gamma function of a value using Lanczos approximation for\n   * small values, and an extended Stirling approximation for large values.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.gamma(n)\n   *\n   * Examples:\n   *\n   *    math.gamma(5)       // returns 24\n   *    math.gamma(-0.5)    // returns -3.5449077018110335\n   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i\n   *\n   * See also:\n   *\n   *    combinations, factorial, permutations\n   *\n   * @param {number | Array | Matrix} n   A real or complex number\n   * @return {number | Array | Matrix}    The gamma of `n`\n   */\n  const gamma = typed(name, {\n    'number': gammaNumber,\n    'Complex': function (n) {\n      let t, x;\n\n      if (n.im === 0) {\n        return gamma(n.re);\n      }\n\n      n = new Complex(n.re - 1, n.im);\n      x = new Complex(gammaP[0], 0);\n\n      for (let i = 1; i < gammaP.length; ++i) {\n        const real = n.re + i; // x += p[i]/(n+i)\n\n        const den = real * real + n.im * n.im;\n\n        if (den !== 0) {\n          x.re += gammaP[i] * real / den;\n          x.im += -(gammaP[i] * n.im) / den;\n        } else {\n          x.re = gammaP[i] < 0 ? -Infinity : Infinity;\n        }\n      }\n\n      t = new Complex(n.re + gammaG + 0.5, n.im);\n      const twoPiSqrt = Math.sqrt(2 * Math.PI);\n      n.re += 0.5;\n      const result = pow(t, n);\n\n      if (result.im === 0) {\n        // sqrt(2*PI)*result\n        result.re *= twoPiSqrt;\n      } else if (result.re === 0) {\n        result.im *= twoPiSqrt;\n      } else {\n        result.re *= twoPiSqrt;\n        result.im *= twoPiSqrt;\n      }\n\n      const r = Math.exp(-t.re); // exp(-t)\n\n      t.re = r * Math.cos(-t.im);\n      t.im = r * Math.sin(-t.im);\n      return multiplyScalar(multiplyScalar(result, t), x);\n    },\n    'BigNumber': function (n) {\n      if (n.isInteger()) {\n        return n.isNegative() || n.isZero() ? new BigNumber(Infinity) : bigFactorial(n.minus(1));\n      }\n\n      if (!n.isFinite()) {\n        return new BigNumber(n.isNegative() ? NaN : Infinity);\n      }\n\n      throw new Error('Integer BigNumber expected');\n    },\n    'Array | Matrix': function (n) {\n      return deepMap(n, gamma);\n    }\n  });\n  /**\n   * Calculate factorial for a BigNumber\n   * @param {BigNumber} n\n   * @returns {BigNumber} Returns the factorial of n\n   */\n\n  function bigFactorial(n) {\n    if (n.isZero()) {\n      return new BigNumber(1); // 0! is per definition 1\n    }\n\n    const precision = config.precision + (Math.log(n.toNumber()) | 0);\n    const Big = BigNumber.clone({\n      precision: precision\n    });\n    let res = new Big(n);\n    let value = n.toNumber() - 1; // number\n\n    while (value > 1) {\n      res = res.times(value);\n      value--;\n    }\n\n    return new BigNumber(res.toPrecision(BigNumber.precision));\n  }\n\n  return gamma;\n});","map":null,"metadata":{},"sourceType":"module"}