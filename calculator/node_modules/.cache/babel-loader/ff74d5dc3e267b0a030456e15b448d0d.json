{"ast":null,"code":"/**\n * Permutes a sparse matrix C = P * A * Q\n *\n * @param {SparseMatrix}  a         The Matrix A\n * @param {Array}   pinv            The row permutation vector\n * @param {Array}   q               The column permutation vector\n * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n *\n * @return {Matrix}                 C = P * A * Q, null on error\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csPermute(a, pinv, q, values) {\n  // a arrays\n  const avalues = a._values;\n  const aindex = a._index;\n  const aptr = a._ptr;\n  const asize = a._size;\n  const adt = a._datatype; // rows & columns\n\n  const m = asize[0];\n  const n = asize[1]; // c arrays\n\n  const cvalues = values && a._values ? [] : null;\n  const cindex = []; // (aptr[n])\n\n  const cptr = []; // (n + 1)\n  // initialize vars\n\n  let nz = 0; // loop columns\n\n  for (let k = 0; k < n; k++) {\n    // column k of C is column q[k] of A\n    cptr[k] = nz; // apply column permutation\n\n    const j = q ? q[k] : k; // loop values in column j of A\n\n    for (let t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n      // row i of A is row pinv[i] of C\n      const r = pinv ? pinv[aindex[t]] : aindex[t]; // index\n\n      cindex[nz] = r; // check we need to populate values\n\n      if (cvalues) {\n        cvalues[nz] = avalues[t];\n      } // increment number of nonzero elements\n\n\n      nz++;\n    }\n  } // finalize the last column of C\n\n\n  cptr[n] = nz; // return C matrix\n\n  return a.createSparseMatrix({\n    values: cvalues,\n    index: cindex,\n    ptr: cptr,\n    size: [m, n],\n    datatype: adt\n  });\n}","map":null,"metadata":{},"sourceType":"module"}