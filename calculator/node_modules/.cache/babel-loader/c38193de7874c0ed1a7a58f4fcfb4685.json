{"ast":null,"code":"import escapeLatexLib from 'escape-latex';\nexport const latexSymbols = {\n  // GREEK LETTERS\n  Alpha: 'A',\n  alpha: '\\\\alpha',\n  Beta: 'B',\n  beta: '\\\\beta',\n  Gamma: '\\\\Gamma',\n  gamma: '\\\\gamma',\n  Delta: '\\\\Delta',\n  delta: '\\\\delta',\n  Epsilon: 'E',\n  epsilon: '\\\\epsilon',\n  varepsilon: '\\\\varepsilon',\n  Zeta: 'Z',\n  zeta: '\\\\zeta',\n  Eta: 'H',\n  eta: '\\\\eta',\n  Theta: '\\\\Theta',\n  theta: '\\\\theta',\n  vartheta: '\\\\vartheta',\n  Iota: 'I',\n  iota: '\\\\iota',\n  Kappa: 'K',\n  kappa: '\\\\kappa',\n  varkappa: '\\\\varkappa',\n  Lambda: '\\\\Lambda',\n  lambda: '\\\\lambda',\n  Mu: 'M',\n  mu: '\\\\mu',\n  Nu: 'N',\n  nu: '\\\\nu',\n  Xi: '\\\\Xi',\n  xi: '\\\\xi',\n  Omicron: 'O',\n  omicron: 'o',\n  Pi: '\\\\Pi',\n  pi: '\\\\pi',\n  varpi: '\\\\varpi',\n  Rho: 'P',\n  rho: '\\\\rho',\n  varrho: '\\\\varrho',\n  Sigma: '\\\\Sigma',\n  sigma: '\\\\sigma',\n  varsigma: '\\\\varsigma',\n  Tau: 'T',\n  tau: '\\\\tau',\n  Upsilon: '\\\\Upsilon',\n  upsilon: '\\\\upsilon',\n  Phi: '\\\\Phi',\n  phi: '\\\\phi',\n  varphi: '\\\\varphi',\n  Chi: 'X',\n  chi: '\\\\chi',\n  Psi: '\\\\Psi',\n  psi: '\\\\psi',\n  Omega: '\\\\Omega',\n  omega: '\\\\omega',\n  // logic\n  'true': '\\\\mathrm{True}',\n  'false': '\\\\mathrm{False}',\n  // other\n  i: 'i',\n  // TODO use \\i ??\n  inf: '\\\\infty',\n  Inf: '\\\\infty',\n  infinity: '\\\\infty',\n  Infinity: '\\\\infty',\n  oo: '\\\\infty',\n  lim: '\\\\lim',\n  'undefined': '\\\\mathbf{?}'\n};\nexport const latexOperators = {\n  'transpose': '^\\\\top',\n  'ctranspose': '^H',\n  'factorial': '!',\n  'pow': '^',\n  'dotPow': '.^\\\\wedge',\n  // TODO find ideal solution\n  'unaryPlus': '+',\n  'unaryMinus': '-',\n  'bitNot': '\\\\~',\n  // TODO find ideal solution\n  'not': '\\\\neg',\n  'multiply': '\\\\cdot',\n  'divide': '\\\\frac',\n  // TODO how to handle that properly?\n  'dotMultiply': '.\\\\cdot',\n  // TODO find ideal solution\n  'dotDivide': '.:',\n  // TODO find ideal solution\n  'mod': '\\\\mod',\n  'add': '+',\n  'subtract': '-',\n  'to': '\\\\rightarrow',\n  'leftShift': '<<',\n  'rightArithShift': '>>',\n  'rightLogShift': '>>>',\n  'equal': '=',\n  'unequal': '\\\\neq',\n  'smaller': '<',\n  'larger': '>',\n  'smallerEq': '\\\\leq',\n  'largerEq': '\\\\geq',\n  'bitAnd': '\\\\&',\n  'bitXor': '\\\\underline{|}',\n  'bitOr': '|',\n  'and': '\\\\wedge',\n  'xor': '\\\\veebar',\n  'or': '\\\\vee'\n};\nexport const latexFunctions = {\n  // arithmetic\n  abs: {\n    1: \"\\\\left|${args[0]}\\\\right|\"\n  },\n  add: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['add'], \"${args[1]}\\\\right)\")\n  },\n  cbrt: {\n    1: \"\\\\sqrt[3]{${args[0]}}\"\n  },\n  ceil: {\n    1: \"\\\\left\\\\lceil${args[0]}\\\\right\\\\rceil\"\n  },\n  cube: {\n    1: \"\\\\left(${args[0]}\\\\right)^3\"\n  },\n  divide: {\n    2: \"\\\\frac{${args[0]}}{${args[1]}}\"\n  },\n  dotDivide: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['dotDivide'], \"${args[1]}\\\\right)\")\n  },\n  dotMultiply: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['dotMultiply'], \"${args[1]}\\\\right)\")\n  },\n  dotPow: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['dotPow'], \"${args[1]}\\\\right)\")\n  },\n  exp: {\n    1: \"\\\\exp\\\\left(${args[0]}\\\\right)\"\n  },\n  expm1: \"\\\\left(e\".concat(latexOperators['pow'], \"{${args[0]}}-1\\\\right)\"),\n  fix: {\n    1: \"\\\\mathrm{${name}}\\\\left(${args[0]}\\\\right)\"\n  },\n  floor: {\n    1: \"\\\\left\\\\lfloor${args[0]}\\\\right\\\\rfloor\"\n  },\n  gcd: \"\\\\gcd\\\\left(${args}\\\\right)\",\n  hypot: \"\\\\hypot\\\\left(${args}\\\\right)\",\n  log: {\n    1: \"\\\\ln\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\log_{${args[1]}}\\\\left(${args[0]}\\\\right)\"\n  },\n  log10: {\n    1: \"\\\\log_{10}\\\\left(${args[0]}\\\\right)\"\n  },\n  log1p: {\n    1: \"\\\\ln\\\\left(${args[0]}+1\\\\right)\",\n    2: \"\\\\log_{${args[1]}}\\\\left(${args[0]}+1\\\\right)\"\n  },\n  log2: \"\\\\log_{2}\\\\left(${args[0]}\\\\right)\",\n  mod: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['mod'], \"${args[1]}\\\\right)\")\n  },\n  multiply: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['multiply'], \"${args[1]}\\\\right)\")\n  },\n  norm: {\n    1: \"\\\\left\\\\|${args[0]}\\\\right\\\\|\",\n    2: undefined // use default template\n\n  },\n  nthRoot: {\n    2: \"\\\\sqrt[${args[1]}]{${args[0]}}\"\n  },\n  nthRoots: {\n    2: \"\\\\{y : $y^{args[1]} = {${args[0]}}\\\\}\"\n  },\n  pow: {\n    2: \"\\\\left(${args[0]}\\\\right)\".concat(latexOperators['pow'], \"{${args[1]}}\")\n  },\n  round: {\n    1: \"\\\\left\\\\lfloor${args[0]}\\\\right\\\\rceil\",\n    2: undefined // use default template\n\n  },\n  sign: {\n    1: \"\\\\mathrm{${name}}\\\\left(${args[0]}\\\\right)\"\n  },\n  sqrt: {\n    1: \"\\\\sqrt{${args[0]}}\"\n  },\n  square: {\n    1: \"\\\\left(${args[0]}\\\\right)^2\"\n  },\n  subtract: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['subtract'], \"${args[1]}\\\\right)\")\n  },\n  unaryMinus: {\n    1: \"\".concat(latexOperators['unaryMinus'], \"\\\\left(${args[0]}\\\\right)\")\n  },\n  unaryPlus: {\n    1: \"\".concat(latexOperators['unaryPlus'], \"\\\\left(${args[0]}\\\\right)\")\n  },\n  // bitwise\n  bitAnd: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['bitAnd'], \"${args[1]}\\\\right)\")\n  },\n  bitNot: {\n    1: latexOperators['bitNot'] + \"\\\\left(${args[0]}\\\\right)\"\n  },\n  bitOr: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['bitOr'], \"${args[1]}\\\\right)\")\n  },\n  bitXor: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['bitXor'], \"${args[1]}\\\\right)\")\n  },\n  leftShift: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['leftShift'], \"${args[1]}\\\\right)\")\n  },\n  rightArithShift: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['rightArithShift'], \"${args[1]}\\\\right)\")\n  },\n  rightLogShift: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['rightLogShift'], \"${args[1]}\\\\right)\")\n  },\n  // combinatorics\n  bellNumbers: {\n    1: \"\\\\mathrm{B}_{${args[0]}}\"\n  },\n  catalan: {\n    1: \"\\\\mathrm{C}_{${args[0]}}\"\n  },\n  stirlingS2: {\n    2: \"\\\\mathrm{S}\\\\left(${args}\\\\right)\"\n  },\n  // complex\n  arg: {\n    1: \"\\\\arg\\\\left(${args[0]}\\\\right)\"\n  },\n  conj: {\n    1: \"\\\\left(${args[0]}\\\\right)^*\"\n  },\n  im: {\n    1: \"\\\\Im\\\\left\\\\lbrace${args[0]}\\\\right\\\\rbrace\"\n  },\n  re: {\n    1: \"\\\\Re\\\\left\\\\lbrace${args[0]}\\\\right\\\\rbrace\"\n  },\n  // logical\n  and: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['and'], \"${args[1]}\\\\right)\")\n  },\n  not: {\n    1: latexOperators['not'] + \"\\\\left(${args[0]}\\\\right)\"\n  },\n  or: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['or'], \"${args[1]}\\\\right)\")\n  },\n  xor: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['xor'], \"${args[1]}\\\\right)\")\n  },\n  // matrix\n  cross: {\n    2: \"\\\\left(${args[0]}\\\\right)\\\\times\\\\left(${args[1]}\\\\right)\"\n  },\n  ctranspose: {\n    1: \"\\\\left(${args[0]}\\\\right)\".concat(latexOperators['ctranspose'])\n  },\n  det: {\n    1: \"\\\\det\\\\left(${args[0]}\\\\right)\"\n  },\n  dot: {\n    2: \"\\\\left(${args[0]}\\\\cdot${args[1]}\\\\right)\"\n  },\n  expm: {\n    1: \"\\\\exp\\\\left(${args[0]}\\\\right)\"\n  },\n  inv: {\n    1: \"\\\\left(${args[0]}\\\\right)^{-1}\"\n  },\n  sqrtm: {\n    1: \"{${args[0]}}\".concat(latexOperators['pow'], \"{\\\\frac{1}{2}}\")\n  },\n  trace: {\n    1: \"\\\\mathrm{tr}\\\\left(${args[0]}\\\\right)\"\n  },\n  transpose: {\n    1: \"\\\\left(${args[0]}\\\\right)\".concat(latexOperators['transpose'])\n  },\n  // probability\n  combinations: {\n    2: \"\\\\binom{${args[0]}}{${args[1]}}\"\n  },\n  factorial: {\n    1: \"\\\\left(${args[0]}\\\\right)\".concat(latexOperators['factorial'])\n  },\n  gamma: {\n    1: \"\\\\Gamma\\\\left(${args[0]}\\\\right)\"\n  },\n  // relational\n  equal: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['equal'], \"${args[1]}\\\\right)\")\n  },\n  larger: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['larger'], \"${args[1]}\\\\right)\")\n  },\n  largerEq: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['largerEq'], \"${args[1]}\\\\right)\")\n  },\n  smaller: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['smaller'], \"${args[1]}\\\\right)\")\n  },\n  smallerEq: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['smallerEq'], \"${args[1]}\\\\right)\")\n  },\n  unequal: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['unequal'], \"${args[1]}\\\\right)\")\n  },\n  // special\n  erf: {\n    1: \"erf\\\\left(${args[0]}\\\\right)\"\n  },\n  // statistics\n  max: \"\\\\max\\\\left(${args}\\\\right)\",\n  min: \"\\\\min\\\\left(${args}\\\\right)\",\n  variance: \"\\\\mathrm{Var}\\\\left(${args}\\\\right)\",\n  // trigonometry\n  acos: {\n    1: \"\\\\cos^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  acosh: {\n    1: \"\\\\cosh^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  acot: {\n    1: \"\\\\cot^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  acoth: {\n    1: \"\\\\coth^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  acsc: {\n    1: \"\\\\csc^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  acsch: {\n    1: \"\\\\mathrm{csch}^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  asec: {\n    1: \"\\\\sec^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  asech: {\n    1: \"\\\\mathrm{sech}^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  asin: {\n    1: \"\\\\sin^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  asinh: {\n    1: \"\\\\sinh^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  atan: {\n    1: \"\\\\tan^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  atan2: {\n    2: \"\\\\mathrm{atan2}\\\\left(${args}\\\\right)\"\n  },\n  atanh: {\n    1: \"\\\\tanh^{-1}\\\\left(${args[0]}\\\\right)\"\n  },\n  cos: {\n    1: \"\\\\cos\\\\left(${args[0]}\\\\right)\"\n  },\n  cosh: {\n    1: \"\\\\cosh\\\\left(${args[0]}\\\\right)\"\n  },\n  cot: {\n    1: \"\\\\cot\\\\left(${args[0]}\\\\right)\"\n  },\n  coth: {\n    1: \"\\\\coth\\\\left(${args[0]}\\\\right)\"\n  },\n  csc: {\n    1: \"\\\\csc\\\\left(${args[0]}\\\\right)\"\n  },\n  csch: {\n    1: \"\\\\mathrm{csch}\\\\left(${args[0]}\\\\right)\"\n  },\n  sec: {\n    1: \"\\\\sec\\\\left(${args[0]}\\\\right)\"\n  },\n  sech: {\n    1: \"\\\\mathrm{sech}\\\\left(${args[0]}\\\\right)\"\n  },\n  sin: {\n    1: \"\\\\sin\\\\left(${args[0]}\\\\right)\"\n  },\n  sinh: {\n    1: \"\\\\sinh\\\\left(${args[0]}\\\\right)\"\n  },\n  tan: {\n    1: \"\\\\tan\\\\left(${args[0]}\\\\right)\"\n  },\n  tanh: {\n    1: \"\\\\tanh\\\\left(${args[0]}\\\\right)\"\n  },\n  // unit\n  to: {\n    2: \"\\\\left(${args[0]}\".concat(latexOperators['to'], \"${args[1]}\\\\right)\")\n  },\n  // utils\n  numeric: function (node, options) {\n    // Not sure if this is strictly right but should work correctly for the vast majority of use cases.\n    return node.args[0].toTex();\n  },\n  // type\n  number: {\n    0: \"0\",\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(\\\\left(${args[0]}\\\\right)${args[1]}\\\\right)\"\n  },\n  string: {\n    0: '\\\\mathtt{\"\"}',\n    1: \"\\\\mathrm{string}\\\\left(${args[0]}\\\\right)\"\n  },\n  bignumber: {\n    0: '0',\n    1: \"\\\\left(${args[0]}\\\\right)\"\n  },\n  complex: {\n    0: '0',\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(\\\\left(${args[0]}\\\\right)+\".concat(latexSymbols['i'], \"\\\\cdot\\\\left(${args[1]}\\\\right)\\\\right)\")\n  },\n  matrix: {\n    0: '\\\\begin{bmatrix}\\\\end{bmatrix}',\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(${args[0]}\\\\right)\"\n  },\n  sparse: {\n    0: '\\\\begin{bsparse}\\\\end{bsparse}',\n    1: \"\\\\left(${args[0]}\\\\right)\"\n  },\n  unit: {\n    1: \"\\\\left(${args[0]}\\\\right)\",\n    2: \"\\\\left(\\\\left(${args[0]}\\\\right)${args[1]}\\\\right)\"\n  }\n};\nexport const defaultTemplate = \"\\\\mathrm{${name}}\\\\left(${args}\\\\right)\";\nconst latexUnits = {\n  deg: '^\\\\circ'\n};\nexport function escapeLatex(string) {\n  return escapeLatexLib(string, {\n    'preserveFormatting': true\n  });\n} // @param {string} name\n// @param {boolean} isUnit\n\nexport function toSymbol(name, isUnit) {\n  isUnit = typeof isUnit === 'undefined' ? false : isUnit;\n\n  if (isUnit) {\n    if (latexUnits.hasOwnProperty(name)) {\n      return latexUnits[name];\n    }\n\n    return '\\\\mathrm{' + escapeLatex(name) + '}';\n  }\n\n  if (latexSymbols.hasOwnProperty(name)) {\n    return latexSymbols[name];\n  }\n\n  return escapeLatex(name);\n}","map":null,"metadata":{},"sourceType":"module"}