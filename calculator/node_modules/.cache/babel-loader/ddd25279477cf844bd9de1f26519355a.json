{"ast":null,"code":"import { isMatrix } from '../../utils/is';\nimport { arraySize } from '../../utils/array';\nimport { isInteger } from '../../utils/number';\nimport { factory } from '../../utils/factory';\nconst name = 'diag';\nconst dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nexport const createDiag =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  matrix,\n  DenseMatrix,\n  SparseMatrix\n}) => {\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    'Array': function (x) {\n      return _diag(x, 0, arraySize(x), null);\n    },\n    'Array, number': function (x, k) {\n      return _diag(x, k, arraySize(x), null);\n    },\n    'Array, BigNumber': function (x, k) {\n      return _diag(x, k.toNumber(), arraySize(x), null);\n    },\n    'Array, string': function (x, format) {\n      return _diag(x, 0, arraySize(x), format);\n    },\n    'Array, number, string': function (x, k, format) {\n      return _diag(x, k, arraySize(x), format);\n    },\n    'Array, BigNumber, string': function (x, k, format) {\n      return _diag(x, k.toNumber(), arraySize(x), format);\n    },\n    'Matrix': function (x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function (x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function (x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function (x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function (x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function (x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    const kSuper = k > 0 ? k : 0;\n    const kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    const ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    const m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // get diagonal matrix\n      const dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    const n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    const vector = []; // loop diagonal\n\n    for (let i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}