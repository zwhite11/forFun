{"ast":null,"code":"/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  const aindex = a._index;\n  const aptr = a._ptr;\n  const asize = a._size; // rows & columns\n\n  const m = asize[0];\n  const n = asize[1]; // allocate result\n\n  const parent = []; // (n)\n  // allocate workspace\n\n  const w = []; // (n + (ata ? m : 0))\n\n  const ancestor = 0; // first n entries in w\n\n  const prev = n; // last m entries (ata = true)\n\n  let i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (let k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (let p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      const r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}","map":null,"metadata":{},"sourceType":"module"}