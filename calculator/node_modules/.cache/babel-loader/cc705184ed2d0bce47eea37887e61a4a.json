{"ast":null,"code":"import { clone } from '../../utils/object';\nimport { format } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nconst name = 'transpose';\nconst dependencies = ['typed', 'matrix'];\nexport const createTranspose =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  matrix\n}) => {\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  const transpose = typed('transpose', {\n    'Array': function (x) {\n      // use dense matrix implementation\n      return transpose(matrix(x)).valueOf();\n    },\n    'Matrix': function (x) {\n      // matrix size\n      const size = x.size(); // result\n\n      let c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          // rows and columns\n          const rows = size[0];\n          const columns = size[1]; // check columns\n\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          } // process storage format\n\n\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    'any': function (x) {\n      return clone(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    const data = m._data; // transposed matrix data\n\n    const transposed = [];\n    let transposedRow; // loop columns\n\n    for (let j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (let i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    const values = m._values;\n    const index = m._index;\n    const ptr = m._ptr; // result matrices\n\n    const cvalues = values ? [] : undefined;\n    const cindex = [];\n    const cptr = []; // row counts\n\n    const w = [];\n\n    for (let x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    let p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    let sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (let i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (let k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        const q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  return transpose;\n});","map":null,"metadata":{},"sourceType":"module"}