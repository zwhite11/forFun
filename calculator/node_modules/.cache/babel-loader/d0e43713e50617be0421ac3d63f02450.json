{"ast":null,"code":"import { clone } from '../../utils/object';\nimport { format } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nconst name = 'trace';\nconst dependencies = ['typed', 'matrix', 'add'];\nexport const createTrace =\n/* #__PURE__ */\nfactory(name, dependencies, ({\n  typed,\n  matrix,\n  add\n}) => {\n  /**\n   * Calculate the trace of a matrix: the sum of the elements on the main\n   * diagonal of a square matrix.\n   *\n   * Syntax:\n   *\n   *    math.trace(x)\n   *\n   * Examples:\n   *\n   *    math.trace([[1, 2], [3, 4]]) // returns 5\n   *\n   *    const A = [\n   *      [1, 2, 3],\n   *      [-1, 2, 3],\n   *      [2, 0, 3]\n   *    ]\n   *    math.trace(A) // returns 6\n   *\n   * See also:\n   *\n   *    diag\n   *\n   * @param {Array | Matrix} x  A matrix\n   *\n   * @return {number} The trace of `x`\n   */\n  return typed('trace', {\n    'Array': function _arrayTrace(x) {\n      // use dense matrix implementation\n      return _denseTrace(matrix(x));\n    },\n    'SparseMatrix': _sparseTrace,\n    'DenseMatrix': _denseTrace,\n    'any': clone\n  });\n\n  function _denseTrace(m) {\n    // matrix size & data\n    const size = m._size;\n    const data = m._data; // process dimensions\n\n    switch (size.length) {\n      case 1:\n        // vector\n        if (size[0] === 1) {\n          // return data[0]\n          return clone(data[0]);\n        }\n\n        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n\n      case 2:\n        // two dimensional\n        const rows = size[0];\n        const cols = size[1];\n\n        if (rows === cols) {\n          // calulate sum\n          let sum = 0; // loop diagonal\n\n          for (let i = 0; i < rows; i++) {\n            sum = add(sum, data[i][i]);\n          } // return trace\n\n\n          return sum;\n        }\n\n        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');\n    }\n  }\n\n  function _sparseTrace(m) {\n    // matrix arrays\n    const values = m._values;\n    const index = m._index;\n    const ptr = m._ptr;\n    const size = m._size; // check dimensions\n\n    const rows = size[0];\n    const columns = size[1]; // matrix must be square\n\n    if (rows === columns) {\n      // calulate sum\n      let sum = 0; // check we have data (avoid looping columns)\n\n      if (values.length > 0) {\n        // loop columns\n        for (let j = 0; j < columns; j++) {\n          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n          const k0 = ptr[j];\n          const k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n          for (let k = k0; k < k1; k++) {\n            // row index\n            const i = index[k]; // check row\n\n            if (i === j) {\n              // accumulate value\n              sum = add(sum, values[k]); // exit loop\n\n              break;\n            }\n\n            if (i > j) {\n              // exit loop, no value on the diagonal for column j\n              break;\n            }\n          }\n        }\n      } // return trace\n\n\n      return sum;\n    }\n\n    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n  }\n});","map":null,"metadata":{},"sourceType":"module"}